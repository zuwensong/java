package com.zuwen.mq;

/**
 * MQ
 *  如何处理消息的重复消费
 *      1.需要保证消息队列的幂等性 幂等性就是指，同一个操作发起一次或者多次请求，结果是一样的
 *      2.使用redis等缓存中间件来存储消费记录，可以给每个消息根据唯一表示存储到redis中，每次重复消费的时候判断redis中是否存在 如果存在就不进行处理
 *  如何处理消息的丢失
 *      数据丢失分三种场景：
 *          1.生产者数据丢失
 *              一般生产者采用confirm模式，每次写消息时都会分配一个唯一ID，MQ如果接受消息成功，则会返回一个ACK告知生产者接受成功，如果接收失败会回调生产者nack接口，生产者可以重新发送消息，
 *              如果生产者迟迟没有收到ack消息，可以将消息维护在缓存中，超时重新发送消息
 *          2.MQ接收消息成功，但是自己弄丢了消息
 *              这种场景需要开启rabbitmq数据持久化机制，就是将消息持久化到磁盘上，这样就算 MQ挂了，再次恢复后也能正常恢复数据，RabbitMQ持久化需要同时持久化queue和消息，rabbitmq持久化可以
 *              配合生产者的confirm模式一起使用，当MQ把消息持久化成功后，再发送ACK给生产者
 *          3.消费者数据丢失
 *              这种场景主要发生在消息被消费者接收，还没来得及处理，消费者服务挂了。这种需要用到消费者端的ACK机制，当消费者消费完成后发送AdMQ，此时MQ才会认为消费成功，否则会将消息发送
 *              给其他的消费者
 *
 * RabbitMQ
 *  RabbitMQ的两种模式
 *      1.transaction模式
 *
 *      2.confirm模式
 *  RabbitMQ交换机类型
 *      1.Direct 根据routing-key完全匹配
 *      2.Topic 根据routing-key模糊匹配
 *      3.Fanout 广播的方式，将消息发送到交换机绑定的所有队列上
 */
public class TotalDemo {
}
