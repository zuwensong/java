package com.zuwen.redis;

/**
 * redis
 *  redis的优点
 *      1.redis是存储在内存中的，所以速度很快，读取速度能达到11W/S,写入速度能达到8W/S
 *      2.redis支持丰富的数据类型：String, List, Set, ZSet, Hash
 *      3.redis支持数据持久化【RDB/AOF】https://blog.csdn.net/liqingtx/article/details/60330555
 *          RDB：定时的将redis内存中的数据生成快照并存储到磁盘上，异步的【启动一个子进程来执行该操作】
 *          AOF：将redis执行过的写指令记录下来，redis重启后会执行这些记录来恢复数据
 *          两种方式可以同时使用，只不过redis会优先使用AOF方式
 * redis中的数据结构
 *  1.string 最常用的数据结构
 *  2.list 列表 底层是一个链表的方式支持左插入、右插入、按范围读取 使用场景如：队列
 *  3.set 无需集合
 *  4.sorted set 有序集合，它存储的时候会同步存储一个序号，用来排序
 *  5.hash 哈希 使用场景，对应频繁修改的对象类型可以考虑使用hash存储,因为hash底层的value是一个map修改属性不需要重新的存储数据
 *
 * redis中的主从复制
 *  主要是解决redis高可用和读写不分离性能瓶颈问题，主节点主要用来写，从节点用来读。
 *  数据同步分两种：
 *      1.全量同步：发生在主从节点第一次连接的时候，此时从节点会发送SYNC命令，主节点收到后会起一个子进程(异步)执行BGSAVE命令将数据保存到一个rdb文件中，完成后发送给从节点，执行期间的写命令会存到一个缓存中，
 *          从节点拿到rbd文件会保存到磁盘中并载入新的数据，完成后会执行主节点期间缓存的写命令。
 *      2.增量同步：在连接主从之后，主节点每次发生写命令都会将命令发送给从节点，然后从节点会执行该命令已完成增量同步。
 *  redis策略：第一次走全量同步，之后走增量同步，当增量同步失败时，才会走全量同步。
 *
 * redis事务
 *  redis中的事务主要是通过将一组命令包裹起来，然后一次性执行完成的主要涉及四个命令
 *      1.MULTI 用来组装一个事务
 *      2.EXEC 用来执行一个事务
 *      3.DISCARD 用来取消一个事务
 *      4.WATCH 监听key，如果Key发生变化，则事务不会执行
 *
 *
 * Redis过期键的删除策略？
 *      1.定期删除
 *          redis每隔100ms都会随机抽取一些key(之所以随机抽取，是因为如果redis中有大量key设置了过期时间，如果全量检查的话，会特别耗费CPU资源)，查看它的过期时间，如果过期了就删除。
 *      2.惰性删除
 *          redis中的key过期了，但是没有被删除，当它下一次被使用的时候会判断过期时间并删除。
 *
 * Redis的回收策略（淘汰策略）?
 *      1.volatile-lru  从设置了过期时间的数据中选择最近最少使用的数据删除
 *      2.volatile-ttl  从设置了过期时间的数据中选择将要过期的数据删除
 *      3.volatile-random   从设置了过期时间的数据中随机删除
 *      4.allkeys-lru 从所有数据中选择最近最少使用的数据删除
 *      5.allkeys-random 从所有数据中随机删除
 *      6.no-eviction 内存达到阈值后,后续的set命令会报错
 *      7.volatile-lfu 从设置了过期时间的数据中选择最少使用的数据删除
 *      8.allkeys-lfu 从所有数据中选择最少使用的数据删除
 *
 * 缓存雪崩和缓存穿透
 *
 * redis缓存不一致的问题
 *  1.双删+超时的方式，这种方式最大的可能性是会出现在超时时间内缓存不一致，而且是发生在服务器宕机的时候，概率很低
 *
 */
public class TotalDemo {
}
